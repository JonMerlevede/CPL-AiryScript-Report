\section{Implementation}

\subsection{Picking a programming language}
We decided to program AiryScript in Scala fairly early on for the following
reasons.
\begin{itemize}
  \item We wanted to be able to really define our own language syntax.
    Generally, this means having our own parser and not merely calling ‘eval’ in
    some other language. Also, all of the members of our team prefer typed
    languages. Therefore, we also wanted to create a typed language. We could
    not see how to do this without making our own parser. We were already in
    possession of some basic parser code for Scala.
  \item Some of the members of our team were already familiar with Scala.
  \item All of the members of our team were already familiar with Java, which
    makes it fairly easy to learn (the very basics of) Scala.
  \item Scala has very good support for pattern matching through case classes
    (i.e. tagged unions). We make extensive use of this in our code.
  \item Some of the members of our team had been looking for a good opportunity
    to get to know Scala for some time.
\end{itemize}


\subsection{Implementation overview}

We divided the implementation in 3 parts:
\begin{enumerate}
\item The parser: Responsible for parsing a string into the right operation, or
returning a parse error if the given expression was incorrect.
\item The operation handler: The actual implementation of all the different
operators. This part is responsible for verifying all the arguments of an
operation and either trowing an error if these arguments were
incorrect/incomplete or performing the operation. Both for verifying aswell as
performing an operation database acces is required.
\item The database: We used an SQL database to backup the system. The
implementation of this database closely resembles the domain model.
\end{enumerate} 
	
\par
All of the operations and types are resembled by a single case class in scala,
which captures all of the required information to use this. The parser will
parse a string into an operation, after which this is passed to the second
phase. The handler can then handle these operations by pattern matching over the
different kinds of operators and their respective arguments.


\input{4-implementation/parser}
\input{4-implementation/handler} 
\input{4-implementation/database}
